---
title: architech
category: mysql
order: 1
---


### mysql架构

<img src="/Users/fuliangchun/Desktop/屏幕快照 2020-12-15 下午9.08.39.png" style="zoom:50%;" />

* server层
  * 连接器  处理连接，授权认证，安全等。wait_timeout 用来控制连接的空闲超时时间，默认值是 8 小时。现在应用都是长连接，如果发生mysql服务内存涨的特别快(连接占用的资源需要断开之后才会释放)
    * 定时断开长连接 或者长事务之后断开连接
    * 5.7以后可以每执行一个比较大的操作以后mysql_reset_connection，来将连接恢复到连接刚创建的状态
  * 缓存 缓存其实就是一个kv结构的数据，key为执行的sql语句，value为查询的结果。
    * 用于优化查询的效率，采用缓存(LRU)，如果发现有直接相同的sql直接返回，省略了解析器解析和优化的过程。**mysql中使用缓存弊大于利**，因为查询缓存失效过于频繁，只要对表进行更新，那么这个表上所有的查询缓存都需要清空。**mysql 8.0中已经将查询缓存去掉了**
  * 分析器  简单来说就是理解当前提交过来的sql语句是要干什么
    * 词法分析   将sql语句进行分析,将关键字识别，将字符串对应成表，查询字段
    * 语法分析   分析语法是否符合mysql规范，符合的话最后会解析成为一个语法树(you have an error in your SQL syntax)
  * 优化器   分析器是理解要做什么的话，优化器则是根据自己的分析来决定如何去做。负责生成执行计划，决定使用什么索引，决定表的连接顺序等。基于CBO(基于成本的一种优化)，例如执行计划中的rows字段就非常重要，mysql的选择执行计划会考虑到rows等一些因素
  * 执行器   获取到执行的计划，然后调用存储引擎的数据接口获取数据(此处其实会判断是否由查询表的权限),存储引擎是按页读取(16k),而执行器是一行一行的调用存储引擎的接口获取数据的

* 存储引擎  负责mysql数据的存储和提取。在mysql中存储引擎是插件式的。可以通过创建表的时候指定engine = innoDB来指定，默认其实就是InnoDB。tips：其实innoDB并不是mysql本身的，是其他公司开发的插件，最终被集成到了mysql中,这就是开源的好处啦

### SQL的执行顺序

#### 查询的执行流程

 查询的执行流程其实相对于简单。

* 由连接器处理连接(很多的client端(就是我们的应用)都采用连接池管理连接(长连接))，用户密码校验，权限校验，安全
* 8.0之前会去缓存中进行查询，若命中则直接返回，否则进行后续步骤
* 分析器 进行词法语法分析，理解sql语句的语义(语法树)
* 优化器根据选择一条自己认为最佳的执行计划
* 执行器按照执行计划去存储引擎中获取数据

#### 执行流程

事务的特点是ACID

* Atomic 原子性  事务中的所有的操作是原子的，不可分割，要么全部成功，要么都失败
* 一致性  从一个一致性状态变成另一个一致性状态
* 隔离性  事务之间是互不影响的
  * 读未提交 Read Uncommit
  * 读已提交 Read commit
  * 可重复读 Reaptable Read
  * 串行化 Serializable
* 持久性 一旦提交操作就永久保存在数据库中



**mysql中采用了一种WAL的思想(write-ahead logging),关键点就是先写日志，再写磁盘。** 为什么要这么做呢？

简单来说就是为了性能，如果每次更新操作都要写磁盘，然后磁盘也要找到那条记录，然后再更新(更新其实有可能设计到索引的修改,页分裂之类的，索引相对于写日志来说复杂程度高很多)。这么整个过程的IO成本(写日志是顺序写，而写到数据文件中就有可能不是顺序写了),查找成本都很高,为了解决这个问题,从而采用了WAL的思想来设计.

问题：mysql采用WAL，由原来的写一次磁盘变成写两次磁盘(redo log,binlog)？为什么说会更加快呢？

假设mysql执行dml语句的时候，会将操作的数据线读入内存中mysql的是先操作内存，在写日志的方式完成数据的更新的。内存中修改会非常快，然后再通过写日志的方式，保持这次更新不丢失.

* 对于redo log和binlog来说，写都是顺序写的,磁盘顺序写很快
* 同时在写入磁盘调用内核的fsync的时候会进行组提交策略，就是会将多个redo log的写合并到一起，一次性执行写入(所以实际的Io并不会比单次写数据库文件多很多)

<img src="/Users/fuliangchun/Desktop/屏幕快照 2020-12-19 下午5.08.08.png" style="zoom:33%;" />

##### Redo log

需要说明一下的就是redo log是inno DB存储引擎独有的**redo log是有固定大小的**,如下图，假设设置了配置为一组 4 个文件，每个文件的大小是 1GB的话.需要说一下的是redo log是循环写入的。每次触发一次从log文件flush到数据文件的操作就往后移动check point，而每次往日志文件中记录则会移动write pos，当二者接近的时候就会触发强制性的flush数据文件的操作。

<img src="/Users/fuliangchun/Desktop/屏幕快照 2020-12-15 下午9.38.56.png" style="zoom:40%;" />

有了redo log之后就可以保证数据库在发生异常重启的时候,之前提交的记录都不会丢失,crash-safe。也有了这种机制，所以Inno DB才实现了ACID中的持久性,以及协助实现了一致性

##### Binlog 

Redo log是引擎层的日志，而InnoDB可以说是server层的日志。所以的存储引擎在做更新操作的时候都会记录binlog中。说一下binlog是没有办法实现crash safe能力的.binlog是记录数据发生了什么变化，更新之前是什么样子更新之后是什么样子(项目中使用BInlog 解析来将更新的数据同步到es中)

**为什么说Binlog不能提供crash safe能力呢？**

假设没有redo log，那么保存数据的流程是 写Binlog->存数据  或者是存数据->写binlog，那么无论哪种在数据库崩溃的时候,那么无论如何利用binlog来恢复都会丢失或者多一些数据.不准确

binlog记录数据有三种模式：

ROW(以行数据的方式),STATEMENT(以执行sql语句的方式) MIXED(混合方式,普通情况下用statement，特殊情况使用row...)**一般推荐使用row**对于使用Binlog进行组成同步的场景下，如果使用statement的话有可能造成主从数据不一致的情况(例如会因为可能使用的索引列不同而执行了不同的执行计划导致操作的数据不同)。对于一些查询如果是用statemnt，Mysql会提示一个警告.这也是为什么会有Mixed这种隔离级别，其会在一些造成歧义的sql语句的时候采用row这种方式

binlog也时长用来做数据库的备份工作,主从之间的复制也是基于binlog来做的

在InnoDB中dml 的执行顺序

<img src="/Users/fuliangchun/Desktop/屏幕快照 2020-12-15 下午10.06.08.png" style="zoom:50%;" />

上面浅色的内容是在引擎层执行的，深色的是在server层执行的。**注意更新的时候是首先将数据更新到引擎的内存中的**

* 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
* 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
* 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
* 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
* 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

##### 脏页

如上面的流程图，当我们在执行upate t set name =xx where id =2，首先判断内存中是否有这行数据，没有的话会去读取数据到内存中，这个读取过程是按页读取(16k)，读取的是一行行的数据,后续更新数据也是更新内存，然后记录日志就算更新完了.**后续如果涉及到这个表的查询其实也查询的是查询的内存**,当数据在内存中不存在才会通过树进行查询.

如果对于内存中的数据进行了更新，这个页就是脏页,**即使是涉及到修改了数据,会变动索引之类的数据也不会里面就更新到数据里面**

问题1：什么时候才会将脏页数据刷到数据中?

* 当 redo log写满了。这时候系统就会停止所有的更新操作，将更新的这部分日志对应的脏页同步到磁盘中，此时所有的更新全部停止，此时写的性能变为0，必须待刷一部分脏页后才能更新,这时就会导致 sql语句 执行的很慢。

* 也可能是系统内存不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，则需要先将脏页同步到磁盘,空出来的给别的数据页使用。

* MySQL 认为系统“空闲”的时候,反正闲着也是闲着反正有机会就同步到磁盘一些数据

* MySQL 正常关闭。这时候，MySQL 会把内存的脏页都同步到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

问题2：脏页写入数据库文件中，会引起页分裂或者页合并

如果脏页中有涉及到索引的变动，则就有可能引起页的合并等操作(例如删除了很多的数据...)

**redo log的两阶段提交**

为什么需要两阶段提交？

因为mysql需要redo log和Binlog处于一致状态，首先写入redo log并处于prepare状态,再写入BInlog，最后将redo log中变成commit状态，最终完成事务的提交.

两阶段也被用来做分布式事务的一个处理方式.即只有在多个都进入了prepare阶段之后，最终所有的事务一起完成提交.

InnoDB从异常中恢复其实默认就会读取redo log和binlog，然后判断其中的状态

* 如果数据在redo log中处于commit状态，则无须从BInlog中去寻找了
* redo log处于prepare状态，binlog中无数据，说明事务未提交就崩溃了 则回滚这个事务
* redo log 处于prepare状态，但是binlog中有数据，则提交这个事务



<img src="/Users/fuliangchun/Desktop/屏幕快照 2020-12-12 下午3.33.45.png" style="zoom:33%;" />

事务的执行流程：

* 如果数据页不在InnoDB的 buffer pool中的话需要数据读入buffer pool
* 更新数据页数据(脏页),原数据写入undo log(原子性)用于回滚，在合适的时候由后台purge线程删除
* 将更新的操作记录到写入redo log buffer中,默认是innodb_flush_log_trx_commit(默认是1，即事务提交就刷盘),但是由于组提交(即会稍微延后调动内核fsync,多个日志一次性提交),此时**redo log的状态为prepare**
* 此时server端收到执行完成消息，然后进行binlog写入，binlog也是先写到Binlog buffer中，不同于redo log buffer是所有线程公用的，binlog buffer是线程独有的(为了保证Binlog的完整性),根据sync_binlog的设置(默认是1，事务提交就里面写入磁盘),这里也会有组提交优化.
* 当Binlog写入完成则将redo log变成commit状态，最终提交事务完成

因为redo log是先写到redo log buffer中，而这里面又有组提交等概念和后台线程定时刷等，则有可能事务还未提交，其部分redo日志事务还未提交，其实日志就有可能提交到磁盘文件中了。如果后续事务回滚，其实也没有影响







